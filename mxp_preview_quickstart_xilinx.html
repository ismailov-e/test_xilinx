<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>VectorBlox MXP Preview: Quickstart for Xilinx</title>
  <style type="text/css">code{white-space: pre;}</style>
<link type="text/css" rel="stylesheet" href="css/bootstrap.css"/>
<link type="text/css" rel="stylesheet" href="css/jquery.ui.all.css"/>
<link type="text/css" rel="stylesheet" href="css/jquery.tocify.css"/>
<style>
body {
    padding-top: 20px;
}
p {
    font-size: 16px;
}
.headerDoc {
    color: #005580;
}

@media (max-width: 767px) {
    #toc {
        position: relative;
        width: 100%;
        margin: 0px 0px 20px 0px;
    }
}
</style>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-48667957-1', 'vectorblox.github.io');
  ga('send', 'pageview');

</script>
</head>
<body>
<div class="container-fluid">
<div class="row-fluid">
<div class="span3">
<div id="toc"></div>
</div>
<div class="span9">
<div id="header">
<h1 class="title">VectorBlox MXP Preview: Quickstart for Xilinx</h1>
</div>
<h1 id="download-bitstream-and-run-a-test-program"><span class="header-section-number">1</span> Download Bitstream and Run a Test Program</h1>
<p>This section describes how to download one of the provided pre-built FPGA bitstreams to a supported development board and how to compile and run a test program on it.</p>
<p>If you have downloaded the VectorBlox MXP preview release from github, the string <strong>TOPDIR</strong> below refers to the top-level directory from the extracted download.</p>
<p>If you have a VectorBlox MXP hardware IP release, the string <strong>TOPDIR</strong> refers to the <code>examples</code> subdirectory of the extracted release.</p>
<h2 id="prerequisites"><span class="header-section-number">1.1</span> Prerequisites</h2>
<p>Before you begin, make sure you have:</p>
<ul>
<li><p>Installed Xilinx ISE 14.7 or Vivado 2013.4.</p></li>
<li><p>Installed and tested the Digilent USB-JTAG drivers (if using ISE).</p></li>
<li><p>A supported development board/kit. See the contents of <code>TOPDIR/boards/</code></p></li>
<li><p>Connected your development board to your computer via USB cable and turned the board on.</p></li>
<li><p>Configured your development board so that FPGA bitstreams and software ELF files can be downloaded via JTAG. For example, on the ZedBoard, the jumpers for MIO[6:2] should all be tied low.</p></li>
</ul>
<h2 id="compiling-and-running-a-test-program"><span class="header-section-number">1.2</span> Compiling and Running a Test Program</h2>
<ol style="list-style-type: decimal">
<li><p><strong>Start a Command Shell.</strong></p>
<p>If using Windows and ISE, select <strong>Start Menu</strong> <span class="math"> → </span> <strong>All Programs</strong> <span class="math"> → </span> <strong>Xilinx Design Tools</strong> <span class="math"> → </span> <strong>ISE Design Suite</strong> <span class="math"> → </span> <strong>Accessories</strong> <span class="math"> → </span> <strong>ISE Design Suite 32/64 Bit Command Prompt</strong>.</p>
<p>If using Windows and Vivado, open a Command Prompt (e.g. go to the <strong>Start Menu</strong>, then type <code>cmd.exe</code> in the &quot;Search program and files&quot; box), change to the Vivado installation directory (e.g. <code>C:\Xilinx\Vivado\2013.4</code>), then run either <code>settings32.bat</code> or <code>settings64.bat</code> depending on whether you are using a 32-bit or 64-bit version of Windows.</p>
<p>In Linux, open a terminal and run the appropriate <code>settings{32,64}.{sh,csh}</code> script in the root of your Xilinx ISE_DS or Vivado installation. (Select 32 or 64 depending on whether you want to use the 32-bit or 64-bit versions of the tools, and select sh or csh depending on whether you are using a Bourne-style shell, such as sh or bash, or a C Shell, such as csh or tcsh.) This sets up the proper environment variables for using the Xilinx development tools.</p></li>
<li><p>Navigate to one of the prebuilt VectorBlox MXP systems for your development board, located in <code>TOPDIR/boards/&lt;board_name&gt;/prebuilt_*</code>.</p>
<p>For example, for the ZedBoard, change directory to <code>TOPDIR/boards/zedboard_arm/prebuilt_zedboard_arm_v16</code> for a 16-lane MXP system.</p></li>
<li><p>Store the path to the directory in a shell variable. In Linux, assuming you are using a Bourne-style shell such as <code>sh</code> or <code>bash</code>, use</p>
<pre><code>PROJ_ROOT=`pwd`</code></pre>
<p>If using <code>csh</code> or <code>tcsh</code>, use</p>
<pre><code>set PROJ_ROOT=`pwd`</code></pre>
<p>In Windows, use</p>
<pre><code>set PROJ_ROOT=%cd%</code></pre></li>
<li><p>Navigate to a test application such as <code>vbw_vec_add_t</code>, located in <code>TOPDIR/software/bmark/vbw_vec_add_t</code>.</p></li>
<li><p><strong>Make the executable.</strong></p>
<p>To compile the program for the FPGA bitstream you previously selected, you need to pass the location of the BSP to <code>make</code>. Assuming the <code>PROJ_ROOT</code> shell variable has been set appropriately, on Linux, run</p>
<pre><code>make clean_all all PROJ_ROOT=$PROJ_ROOT</code></pre>
<p>On Windows, run</p>
<pre><code>make clean_all all PROJ_ROOT=%PROJ_ROOT%</code></pre>
<p>After a long list of messages and a few seconds, the file <strong>test.elf</strong> should have been created.</p>
<p>Note that we used the <code>clean_all</code> target first to ensure that any libraries that might have been compiled against a different BSP in the past were cleaned and re-compiled. If you know that the libraries were already compiled for the selected BSP, you can omit the <code>clean_all</code> target.</p></li>
<li><p><strong>Program the FPGA.</strong></p>
<p>We provide a make target to program the FPGA with XMD. In Linux, use</p>
<pre><code>make pgm PROJ_ROOT=$PROJ_ROOT</code></pre>
<p>In Windows, use</p>
<pre><code>make pgm PROJ_ROOT=%PROJ_ROOT%</code></pre></li>
</ol>
<!---
    `impact -batch etc/download.cmd`
or
    xmd:
        connect arm hw
        rst -srst
        fpga -f SDK/SDK_Export/hw/system.bit
        source SDK/SDK_Export/hw/ps7_init.tcl
        ps7_init
        ps7_post_config
        exit
-->


<ol start="8" style="list-style-type: decimal">
<li><p>Open a serial port terminal emulator to prepare to view the output from the board’s USB-UART. On Linux, you can, for example, open a new terminal and run <code>picocom -b 38400 /dev/ttyUSB0</code> for the Atlys or <code>picocom -b 115200 /dev/ttyACM0</code> for the ZedBoard. On Windows, use a program such as PuTTY to connect to the USB serial port.</p></li>
<li><p><strong>Download the executable.</strong></p>
<p>We provide a make target to download the ELF with XMD. In Linux, use</p>
<pre><code>make run PROJ_ROOT=$PROJ_ROOT</code></pre>
<p>In Windows, use</p>
<pre><code>make run PROJ_ROOT=%PROJ_ROOT%</code></pre></li>
</ol>
<!---
    `xmd -tcl xmd_mb.tcl`

         connect arm hw
         dow test.elf
         con
-->

<ol start="9" style="list-style-type: decimal">
<li><strong>View execution output.</strong> You should see output in the serial terminal emulator you opened in an earlier step. The executable may use stdin or stdout for printf, scanf, and similar functions.</li>
</ol>
<h1 id="video-demo-application"><span class="header-section-number">2</span> Video Demo Application</h1>
<p>We have written a demonstration program that runs on supported boards with video output capability. It provides a visual demonstration of the acceleration capabilities of the MXP processor by allowing the user to see the performance difference between algorithms running on the scalar host CPU alone and vectorized MXP implementations of the same algorithms.</p>
<p>On systems with video output, the algorithms demonstrated are</p>
<ul>
<li><p>A two-dimensional n-body particle repulsion simulation with 512 particles and an external force that varies according to a Lissajous pattern. Q16.16 fixed-point arithmetic is used. The MXP implementation of the algorithm uses a custom instruction pipeline that computes the sum of the forces from all other particles on a given particle. The pipeline is described in the following conference paper: A. Severance, J. Edwards, H. Omidian, G. Lemieux, &quot;Soft Vector Processors with Streaming Pipelines,&quot; <em>International Symposium on Field-Programmable Gate Arrays (FPGA)</em>, February, 2014 (<a href="http://www.ece.ubc.ca/~lemieux/publications/severance-fpga2014.pdf">http://www.ece.ubc.ca/~lemieux/publications/severance-fpga2014.pdf</a>). The MXP implementation also makes use of a custom instruction for fixed-point division, if available.</p></li>
<li><p>Mandelbrot set calculation at different zoom levels.</p></li>
<li><p>Sobel edge detection run on half of the screen after each frame of the n-body particle simulation.</p></li>
</ul>
<p>On systems that also have video input, some additional algorithms are demonstrated:</p>
<ul>
<li><p>Sobel edge detection on the video input.</p></li>
<li><p>Motion estimation (motion tracking) on the video input. Two boxes track motion in the input video using a sum-of-absolute-differences calculation. The boxes are re-centred every 400 input frames.</p></li>
<li><p>Face Detection on the video input using Haar-like features. A green box is drawn around each detected face.</p></li>
<li><p>Multi-algorithm mode with the particle simulation overlaid on top of the video input, with edge detection also running in the top left quadrant, motion estimation in the top right quadrant, and video inversion in the bottom right quadrant.</p></li>
</ul>
<p>Below are screen captures of some of the algorithms in action:</p>
<div class="figure">
<img src="images/demo_particle.png" alt="Particle Repulsion Simulation" /><p class="caption">Particle Repulsion Simulation</p>
</div>
<div class="figure">
<img src="images/demo_mandel.png" alt="Mandelbrot Set" /><p class="caption">Mandelbrot Set</p>
</div>
<div class="figure">
<img src="images/demo_sobel.png" alt="Sobel Edge Detection" /><p class="caption">Sobel Edge Detection</p>
</div>
<div class="figure">
<img src="images/demo_haar.png" alt="Haar Face Detection" /><p class="caption">Haar Face Detection</p>
</div>
<div class="figure">
<img src="images/demo_multi2.png" alt="Multi-Algorithm Mode" /><p class="caption">Multi-Algorithm Mode</p>
</div>
<h2 id="zedboard-hdmi-output-demo"><span class="header-section-number">2.1</span> ZedBoard HDMI Output Demo</h2>
<p>This ZedBoard demo displays 1920x1080p 60Hz on the HDMI port. Connect a 1080p monitor to the on-board HDMI port to see video output.</p>
<p>We have provided pre-compiled ELF files for your convenience, but you can also compile the demo yourself by following the instructions in the <a href="#compile_zedboard_hdmi_demo">section below</a>.</p>
<p>To run the demo, first open up an ISE Command Prompt, then go to the directory containing the pre-built bitstream you wish to use. e.g. for the ARM-based V16 system:</p>
<pre><code>cd boards/zedboard_hdmi_arm/prebuilt_zedboard_hdmi_arm_v16</code></pre>
<p>For the MicroBlaze-based V16 system, use</p>
<pre><code>cd boards/zedboard_hdmi_mb/prebuilt_zedboard_hdmi_mb_v16</code></pre>
<p><strong>We recommend you power-cycle the ZedBoard before loading the bitstream.</strong></p>
<p>Connect to the ZedBoard's USB-UART with a terminal emulator program to prepare to view the serial console output. Use 115200 bps, 8 bits per character, no parity.</p>
<p>Program the FPGA and download the ELF with the provided XMD Tcl script:</p>
<pre><code>xmd -tcl xmd_demo.tcl</code></pre>
<p>The DIP switches near the OLED are used to select the mode of operation.</p>
<p><strong>SW0</strong> Toggles between the Mandelbrot and Particle Repulsion algorithms.</p>
<p><strong>SW1</strong> When running Particle Repulsion, toggles Edge Detection on the left half of the screen.</p>
<p><strong>SW2</strong> Toggles between the ARM-only (or MicroBlaze-only) implementation of the algorithm (scalar mode) and the vectorized MXP implementation of the algorithm (vector mode).</p>
<h3 id="compile_zedboard_hdmi_demo"><span class="header-section-number">2.1.1</span> Recompiling the ZedBoard HDMI Output Demo</h3>
<p>From an ISE Command Prompt, go to the directory containing the pre-built bitstream you wish to use. e.g. for the ARM-based V16 system:</p>
<pre><code>cd boards/zedboard_hdmi_arm/prebuilt_zedboard_hdmi_arm_v16</code></pre>
<p>For the MicroBlaze-based V16 system, use</p>
<pre><code>cd boards/zedboard_hdmi_mb/prebuilt_zedboard_hdmi_mb_v16</code></pre>
<p>Store the path to the directory in a shell variable. In Linux use</p>
<pre><code>PROJ_ROOT=`pwd`</code></pre>
<p>in <code>sh</code> or <code>bash</code>, or</p>
<pre><code>set PROJ_ROOT=`pwd`</code></pre>
<p>in <code>csh</code> or <code>tcsh</code>.</p>
<p>In Windows, use</p>
<pre><code>set PROJ_ROOT=%cd%</code></pre>
<p>Go to the demo directory:</p>
<pre><code>cd ../../../software/demo/zedboard</code></pre>
<p>Compile the demo. In Linux, use</p>
<pre><code>make clean_all all PROJ_ROOT=$PROJ_ROOT</code></pre>
<p>In Windows, use</p>
<pre><code>make clean_all all PROJ_ROOT=%PROJ_ROOT%</code></pre>
<p>Program the FPGA. We provide a make target to do this with XMD. In Linux, use</p>
<pre><code>make pgm PROJ_ROOT=$PROJ_ROOT</code></pre>
<p>In Windows, use</p>
<pre><code>make pgm PROJ_ROOT=%PROJ_ROOT%</code></pre>
<p>Connect to the ZedBoard's USB-UART with a terminal emulator program to prepare to view the serial console output. Use 115200 bps, 8 bits per character, no parity.</p>
<p>Download the ELF to the board. Again, we provide a make target to do this with XMD. In Linux, use</p>
<pre><code>make run PROJ_ROOT=$PROJ_ROOT</code></pre>
<p>In Windows, use</p>
<pre><code>make run PROJ_ROOT=%PROJ_ROOT%</code></pre>
<h2 id="zedboard-with-fmc-imageon-hdmi-daughter-card-demo"><span class="header-section-number">2.2</span> ZedBoard with FMC-IMAGEON HDMI Daughter Card Demo</h2>
<p>The <code>zedboard_imageon</code> demo uses Avnet's FMC-IMAGEON daughter card for video input and output. A 1920x1080p 60Hz video source should be connected to the HDMI IN port, and a 1080p monitor should be connected to the HDMI OUT port.</p>
<p>We have provided pre-compiled ELF files for the demo because it uses some Avnet reference code which we do not have permission to redistribute. Please see the <a href="#compile_zedboard_imageon_demo">section below</a> if you wish to compile the demo yourself.</p>
<p>To run the demo, first open up an ISE Command Prompt, then go to the directory containing the pre-built bitstream you wish to use. e.g. for the ARM-based V16 system:</p>
<pre><code>cd boards/zedboard_imageon_arm/prebuilt_zedboard_imageon_arm_v16</code></pre>
<p>For the MicroBlaze-based V16 system, use</p>
<pre><code>cd boards/zedboard_imageon_mb/prebuilt_zedboard_imageon_mb_v16</code></pre>
<p><strong>We recommend you power-cycle the ZedBoard before loading the bitstream.</strong></p>
<p>Connect to the ZedBoard's USB-UART with a terminal emulator program to prepare to view the serial console output. Use 115200 bps, 8 bits per character, no parity.</p>
<p>Program the FPGA and download the ELF with the provided XMD Tcl script:</p>
<pre><code>xmd -tcl xmd_demo.tcl</code></pre>
<p>The DIP switches near the OLED are used to select the mode of operation.</p>
<p><strong>SW7-4</strong> should all be 0 (off).</p>
<p><strong>SW2-0</strong> are used to select from the modes below:</p>
<ul>
<li>000 - Video Pass-through</li>
<li>001 - Particle Repulsion</li>
<li>010 - Edge Detection on the input video</li>
<li>011 - Motion Estimation on the input video</li>
<li>100 - Mandelbrot</li>
<li>101 - Haar Face Detection on the input video</li>
<li>110 - Split Mode (Particle Repulsion with Edge Detection running on the right half of the screen)</li>
<li>111 - Multi Mode (Particle Repulsion overlaid on the input video with Edge Detection, Motion Estimation, Inversion running in different quadrants)</li>
</ul>
<p><strong>SW3</strong> toggles between the ARM-only (or MicroBlaze-only) implementation of the algorithm (scalar mode) and the vectorized MXP implementation of the algorithm (vector mode).</p>
<p><strong>NOTE:</strong> The pre-built bitstreams use a time-limited evaluation version of Xilinx's Chroma Resampler IP core (v_cresample) for conversion between YCbCr 4:2:2 and YCbCr 4:4:4 formats, so the video pipelines will stop working (the output will go blank) after about an hour. You will need to power cycle the board before reloading the bitstream.</p>
<h3 id="compile_zedboard_imageon_demo"><span class="header-section-number">2.2.1</span> Recompiling the ZedBoard + FMC-IMAGEON Demo</h3>
<p>We have provided pre-compiled ELFs for the demo because it uses some Avnet reference code which cannot be redistributed by others.</p>
<p>Read this section if you wish to compile the demo yourself.</p>
<p>See the file <code>00-README.txt</code> in <code>software/demo/zedboard_imageon</code> and follow the instructions for downloading the Avnet reference code that we do not have permission to redistribute. Make sure the necessary files are copied to <code>software/demo/zedboard_imageon</code>.</p>
<p>From an ISE Command Prompt, go to the directory containing the pre-built bitstream you wish to use. e.g. for the ARM-based V16 system:</p>
<pre><code>cd boards/zedboard_imageon_arm/prebuilt_zedboard_imageon_arm_v16</code></pre>
<p>For the MicroBlaze-based V16 system, use</p>
<pre><code>cd boards/zedboard_imageon_mb/prebuilt_zedboard_imageon_mb_v16</code></pre>
<p>Store the path to the directory in a shell variable. In Linux use</p>
<pre><code>PROJ_ROOT=`pwd`</code></pre>
<p>in <code>sh</code> or <code>bash</code>, or</p>
<pre><code>set PROJ_ROOT=`pwd`</code></pre>
<p>in <code>csh</code> or <code>tcsh</code>.</p>
<p>In Windows, use</p>
<pre><code>set PROJ_ROOT=%cd%</code></pre>
<p>Go to the demo directory:</p>
<pre><code>cd ../../../software/demo/zedboard_imageon</code></pre>
<p>Compile the demo. In Linux, use</p>
<pre><code>make clean_all all PROJ_ROOT=$PROJ_ROOT</code></pre>
<p>In Windows, use</p>
<pre><code>make clean_all all PROJ_ROOT=%PROJ_ROOT%</code></pre>
<p>Program the FPGA. We provide a make target to do this with XMD. In Linux, use</p>
<pre><code>make pgm PROJ_ROOT=$PROJ_ROOT</code></pre>
<p>In Windows, use</p>
<pre><code>make pgm PROJ_ROOT=%PROJ_ROOT%</code></pre>
<p>Connect to the ZedBoard's USB-UART with a terminal emulator program to prepare to view the serial console output. Use 115200 bps, 8 bits per character, no parity.</p>
<p>Download the ELF to the board. Again, we provide a make target to do this with XMD. In Linux, use</p>
<pre><code>make run PROJ_ROOT=$PROJ_ROOT</code></pre>
<p>In Windows, use</p>
<pre><code>make run PROJ_ROOT=%PROJ_ROOT%</code></pre>
</div>
</div>
</div>
<script src="js/jquery-1.8.3.min.js"></script>
<script src="js/jquery-ui-1.9.1.custom.min.js"></script>
<script src="js/bootstrap.js"></script>
<script src="js/jquery.tocify.min.js"></script>
<script>
$(function() {
    var toc = $("#toc").tocify({
        selectors: "h1, h2",
        history: false,
        smoothScrollSpeed: "fast",
        }).data("toc-tocify");
      $(".optionName").popover({ trigger: "hover" });
});
</script>
</body>
</html>
