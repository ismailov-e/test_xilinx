<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>VectorBlox MXP Quickstart for Xilinx</title>
  <style type="text/css">code{white-space: pre;}</style>
<link type="text/css" rel="stylesheet" href="css/bootstrap.css"/>
<link type="text/css" rel="stylesheet" href="css/jquery.ui.all.css"/>
<link type="text/css" rel="stylesheet" href="css/jquery.tocify.css"/>
<style>
body {
    padding-top: 20px;
}
p {
    font-size: 16px;
}
.headerDoc {
    color: #005580;
}

@media (max-width: 767px) {
    #toc {
        position: relative;
        width: 100%;
        margin: 0px 0px 20px 0px;
    }
}
</style>
</head>
<body>
<div class="container-fluid">
<div class="row-fluid">
<div class="span3">
<div id="toc"></div>
</div>
<div class="span9">
<div id="header">
<h1 class="title">VectorBlox MXP Quickstart for Xilinx</h1>
</div>
<h1 id="quickstart_install"><span class="header-section-number">1</span> Installation</h1>
<p>The VectorBlox MXP is packaged for easy integration with Xilinx Platform Studio (XPS) and the Xilinx Embedded Development Kit (EDK).</p>
<h2 id="prerequisites"><span class="header-section-number">1.1</span> Prerequisites</h2>
<p>Before you begin, make sure you have:</p>
<ul>
<li><p>Xilinx ISE Design Suite 14.7 or later. Make sure that you install an edition that includes Xilinx Platform Studio (XPS) and the Embedded Development Kit (EDK). (As of this writing, XPS and the EDK are automatically installed with ISE WebPACK, ISE Embedded Edition, and ISE System Edition.)</p></li>
<li><p>A license for Xilinx Platform Studio (XPS). An XPS license is included with licenses for the Embedded and System Editions of ISE, but not with licenses for the WebPACK, Logic, and DSP Editions. Xilinx sells a separate XPS license for use with these products. Xilinx also offers a 30-day evaluation license for all of their design tools; visit <a href="http://www.xilinx.com/getlicense">http://www.xilinx.com/getlicense</a>.</p></li>
<li><p>One of the development boards for which we provide pre-built bitstreams, if you wish to follow the examples in this document. Currently we provide pre-built systems for the Digilent Atlys and Avnet ZedBoard kits.</p></li>
<li><p>A VectorBlox MXP release, provided as a zip or tar.gz file.</p></li>
</ul>
<h2 id="installation"><span class="header-section-number">1.2</span> Installation</h2>
<ul>
<li><p>Download and install Xilinx ISE Design Suite according to Xilinx’s instructions.</p>
<p><a href="http://www.xilinx.com/support/download/index.htm">http://www.xilinx.com/support/download/index.htm</a></p>
<p>Note the pathname where the tools are installed. For example, under Windows, the default installation location for version 14.7 is <code>C:\Xilinx\14.7\ISE_DS</code>. The <code>settings32.bat</code> and <code>settings64.bat</code> batch scripts in this directory define the <strong>XILINX</strong> and <strong>XILINX_EDK</strong> environment variables which point to the ISE and EDK installation directories. Unix installations contain Bourne shell and C shell scripts (<code>settings{32,64}.{sh,csh}</code>) that define these variables.</p></li>
<li><p>Extract the VectorBlox zip or tar.gz file.</p></li>
<li><p>The <strong>pcores</strong>, <strong>drivers</strong>, and <strong>sw_services</strong> directories need to be copied to a location where the EDK tools can find them. You can choose one of the following options:</p>
<dl>
<dt>In the EDK installation directory.</dt>
<dd><p>Perform the following:</p>
<ul>
<li>Create the directories <code>$XILINX_EDK/hw/VectorBlox</code> and <code>$XILINX_EDK/sw/VectorBlox</code>.</li>
<li>Copy the <strong>pcores</strong> directory to <code>$XILINX_EDK/hw/VectorBlox</code></li>
<li>Copy the <strong>drivers</strong> and <strong>sw_services</strong> directories to <code>$XILINX_EDK/sw/VectorBlox</code>.</li>
</ul>
<p>In XPS, VectorBlox cores will appear in the IP Catalog under the <strong>EDK Install</strong> section. The Xilinx SDK will be able to automatically find the VectorBlox <code>drivers</code> and <code>sw_services</code> directories.</p>
</dd>
<dt>In your XPS project directory.</dt>
<dd><p>Copy the <strong>pcores</strong>, <strong>drivers</strong>, and <strong>sw_services</strong> directories to the root directory of your XPS project (i.e. the directory where your XMP and MHS files reside). In XPS, VectorBlox cores will appear in the IP Catalog under <strong>Project Local PCores</strong>. However, in order for the Xilinx SDK to be able to find the VectorBlox drivers and sw_services directories, the XPS project directory will need to be manually added to the XSDK search path, either with the XSDK <code>-lp &lt;path&gt;</code> command-line option, or from the XSDK GUI (<strong>Xilinx Tools</strong> <span class="math"> → </span> <strong>Repositories</strong> <span class="math"> → </span> <strong>Local Repositories</strong> <span class="math"> → </span> <strong>New…</strong>).</p>
</dd>
<dt>In another directory.</dt>
<dd><p>Create a directory called VectorBlox in a location of your choosing. Copy the <strong>pcores</strong>, <strong>drivers</strong>, and <strong>sw_services</strong> directories to the VectorBlox directory. Add the <strong>parent</strong> of the VectorBlox directory to the XPS project search path (<strong>Project</strong> <span class="math"> → </span> <strong>Project Options…</strong> <span class="math"> → </span> <strong>Advanced Options</strong> <span class="math"> → </span> <strong>Project Peripheral Repository Search Path</strong>). Alternatively, you can add a <strong>ModuleSearchPath</strong> line to the XPS XMP project file, e.g.</p>
<pre><code>ModuleSearchPath: /path/to/peripheral/repository</code></pre>
<p>VectorBlox cores will appear in the IP Catalog under <strong>Project Peripheral Repository0</strong>. The VectorBlox directory will need to be manually added to the Xilinx SDK search path as described in the previous paragraph.</p>
</dd>
</dl></li>
</ul>
<p>If you wish to use the pre-built bitstreams we provide for the Digilent Atlys or Avnet ZedBoard, you should also perform the following steps:</p>
<ul>
<li><p>Install the Digilent plugin. This is a plugin for the Xilinx tools which adds support for the USB-JTAG configuration hardware used on Digilent boards. The plugin might have already been installed when you installed ISE, but if not, you can find the installation program in <code>$XILINX/bin/nt/digilent</code> and <code>$XILINX/bin/nt64/digilent</code> on Windows, or in <code>$XILINX/bin/lin/digilent</code> and <code>$XILINX/bin/lin64/digilent</code> on Linux.</p>
<p>To test that the plugin is correctly installed:</p>
<ol style="list-style-type: decimal">
<li><p>Power on the Atlys or ZedBoard.</p></li>
<li><p>Connect a USB cable between the board’s “PROG” micro-USB port and your computer.</p></li>
<li><p>Open a command-line window. (On Windows, select <strong>Start Menu</strong> <span class="math"> → </span> <strong>All Programs</strong> <span class="math"> → </span> <strong>Xilinx Design Tools</strong> <span class="math"> → </span> <strong>ISE Design Suite</strong> <span class="math"> → </span> <strong>Accessories</strong> <span class="math"> → </span> <strong>ISE Design Suite 32/64 Bit Command Prompt</strong>; on Linux, open a shell and source the appropriate <code>settings{32,64}.{sh,csh}</code> script.)</p></li>
<li><p>Run <code>impact -batch</code>.</p></li>
<li><p>At the iMPACT prompt, enter the commands</p>
<pre><code>setmode -bs
setcable -p auto
identify -inferir</code></pre>
<p>If everything is installed correctly, you should see output similar to the following for the Atlys:</p>
<pre><code>INFO:iMPACT - Digilent Plugin: Plugin Version: 2.4.4
INFO:iMPACT - Digilent Plugin: found 1 device(s).
INFO:iMPACT - Digilent Plugin: opening device: &quot;Atlys&quot;, SN:210178409043
INFO:iMPACT - Digilent Plugin: User Name: Atlys
INFO:iMPACT - Digilent Plugin: Product Name: Atlys
INFO:iMPACT - Digilent Plugin: Serial Number: 210178409043
INFO:iMPACT - Digilent Plugin: Product ID: 00C0010C
INFO:iMPACT - Digilent Plugin: Firmware Version: 0305
INFO:iMPACT - Digilent Plugin: JTAG Port Number: 0
INFO:iMPACT - Digilent Plugin: JTAG Clock Frequency: 1600000 Hz

Identifying chain contents...&#39;0&#39;: : Manufacturer&#39;s ID = Xilinx xc6slx45,
   Version : 4
INFO:iMPACT:1777 -
   Reading /xilinx/14.7/ISE_DS/ISE/spartan6/data/xc6slx45.bsd...
INFO:iMPACT:501 - &#39;1&#39;: Added Device xc6slx45 successfully.</code></pre>
<p>For the ZedBoard, the output should look like:</p>
<pre><code>INFO:iMPACT - Digilent Plugin: Plugin Version: 2.4.4
INFO:iMPACT - Digilent Plugin: found 1 device(s).
INFO:iMPACT - Digilent Plugin: opening device: &quot;Zed&quot;, SN:210248447698
INFO:iMPACT - Digilent Plugin: User Name: Zed
INFO:iMPACT - Digilent Plugin: Product Name: Digilent Zed
INFO:iMPACT - Digilent Plugin: Serial Number: 210248447698
INFO:iMPACT - Digilent Plugin: Product ID: 00E00153
INFO:iMPACT - Digilent Plugin: Firmware Version: 0105
INFO:iMPACT - Digilent Plugin: JTAG Port Number: 0
INFO:iMPACT - Digilent Plugin: JTAG Clock Frequency: 10000000 Hz

Identifying chain contents...&#39;0&#39;: : Manufacturer&#39;s ID = Xilinx xc7z020,
   Version : 0
INFO:iMPACT:1777 -
   Reading /xilinx/14.7/ISE_DS/ISE/zynq/data/xc7z020.bsd...
INFO:iMPACT - Using CseAdapterBSDevice
INFO:iMPACT:501 - &#39;1&#39;: Added Device xc7z020 successfully.</code></pre></li>
</ol></li>
<li><p>For the Atlys, you might need to install a driver for the EXAR XR21V1410 USB UART. Linux and Windows drivers can be downloaded from <a href="http://www.exar.com/connectivity/uart-and-bridging-solutions/usb-uarts/xr21v1410">http://www.exar.com/connectivity/uart-and-bridging-solutions/usb-uarts/xr21v1410</a>. (Windows 7 should automatically find and install the driver.)</p></li>
<li><p>For the ZedBoard, you might need to install a driver for the Cypress CY7C64225 USB UART. Instructions for installing the Windows driver are available on [zedboard.org] under Support <span class="math"> → </span> Documentation <span class="math"> → </span> Cypress USB-to-UART Setup Guide, but most versions of Windows should automatically find and install the driver. Popular Linux distributions should already include support for the Cypress USB UART with the USB cdc_acm kernel module (the device should appear as /dev/ttyACM*).</p></li>
<li><p>Install a serial port terminal emulation program (e.g. PuTTY on Windows, picocom on Linux) to display output from the board’s USB UART.</p></li>
</ul>
<h1 id="quickstart_hardware"><span class="header-section-number">2</span> Hardware</h1>
<p>This section describes how to instantiate the VectorBlox MXP processor into a MicroBlaze- or Zynq-based Xilinx Platform Studio project. Some familiarity with XPS is assumed; please refer to Xilinx’s XPS and EDK documentation for further details. (<em>EDK Concepts, Tools, and Techniques</em> (UG683) is a good place to start.)</p>
<p>You must ensure that the VectorBlox MXP design files are in the XPS IP Search Path; please see the Installation section for details.</p>
<h2 id="microblaze_system_configuration"><span class="header-section-number">2.1</span> MicroBlaze System Configuration</h2>
<p>The figure below shows the XPS view of a simple MicroBlaze-based embedded system. The system includes some on-chip RAM connected to LMB buses, a DDR2 DRAM controller connected to an AXI4 interconnect, and some peripherals connected to an AXI4-Lite interconnect. We will show how to add an MXP processor to this system.</p>
<p><img src="images/xps_mb_system.png" /> <img src="images/xps_mb_address_map.png" /></p>
<h3 id="microblaze_configuration"><span class="header-section-number">2.1.1</span> MicroBlaze Configuration</h3>
<ul>
<li><p>The MXP is little-endian, so the MicroBlaze must be configured to be little-endian as well (<code>C_ENDIANNESS</code> = 1). (This is the default setting for a MicroBlaze processor with AXI4 interfaces.)</p></li>
<li><p>We recommend that you enable the MicroBlaze’s Instruction Cache, Data Cache, and Branch Target Cache, as these will significantly improve performance. The figure below shows the MicroBlaze’s cache configuration panel. The cacheable address range is also defined in this panel and typically includes the DRAM address range.</p>
<div class="figure">
<img src="images/xps_mb_cache_cfg.png" />
</div></li>
<li><p>The MXP connects to the MicroBlaze via a Direct FSL (Fast Simplex Link) interface, so you must set the number of FSL links to at least 1 (<code>C_USE_FSL_LINKS</code> = 1). In the MicroBlaze advanced core configuration dialog box, select the <strong>Buses</strong> tab, set <strong>Number of Stream Links</strong> to 1 or more, and set <strong>Select Stream Interfaces</strong> to FSL.</p>
<div class="figure">
<img src="images/xps_mb_fsl_cfg.png" />
</div>
<p>Note that MXP software driver assumes that the MXP processor is connected to FSL0 (DRFSL0/DWFSL0). If you need to use FSL0 for another purpose, please contact VectorBlox for a modified version of the MXP driver.</p></li>
</ul>
<h2 id="zynq_system_configuration"><span class="header-section-number">2.2</span> Zynq System Configuration</h2>
<!--- XXX To be expanded -->

<p>The Zynq PS S_AXI_HPx port (High Performance AXI Slave Port) that the MXP's DMA engine connects to should be configured to be as wide as possible (64-bits wide for vector widths greater than one).</p>
<h2 id="axi_considerations"><span class="header-section-number">2.3</span> AXI Considerations</h2>
<p>Avoid using bus masters that perform narrow transfers (i.e. transfers whose size, as specified by AxSIZE[2:0], is smaller than the data bus width).</p>
<p>If a bus master advertises that it uses narrow bursts (<code>C_M_AXI_SUPPORTS_NARROW_BURST</code> = 1 in its MPD file), XPS will by default automatically enable narrow burst support in all AXI4 slaves connected to that bus master. Narrow burst support does not only increase area, but can also affect performance. The maximum achievable throughput of some memory controllers can be significantly degraded when narrow burst support is enabled; the Spartan-6 AXI DDR Controller (axi_s6_ddrx) is one known example.</p>
<h2 id="support_for_uncached_access"><span class="header-section-number">2.4</span> Support for Uncached Access to Cached Memory Region</h2>
<p>The VBX API library provides some functions to simplify sharing of data between the host CPU (MicroBlaze or ARM Cortex-A9) and the MXP without requiring the application programmer to explicitly flush data cache lines. These functions include <code>vbx_shared_malloc()</code>, <code>vbx_shared_free()</code>, <code>vbx_remap_uncached()</code>, and <code>vbx_remap_cached()</code>.</p>
<p>The library assumes that the host CPU can access a cached memory region in an uncached manner (i.e. bypassing the data cache) simply by setting the most significant bit of the physical address to 1.</p>
<h3 id="microblaze-data-cache-bypass"><span class="header-section-number">2.4.1</span> MicroBlaze Data Cache Bypass</h3>
<p>Unfortunately MicroBlaze does not have built-in support for bypassing the data cache (other than disabling the entire data cache), but we can add equivalent functionality by adding some bus connections and placing some restrictions on the system’s address map:</p>
<ul>
<li><p>The MicroBlaze’s cached memory region must be contained within the range <code>0x0</code> to <code>0x7fff_ffff</code>.</p></li>
<li><p>Any memory peripherals that are to be shared between MicroBlaze and MXP must be accessible in the range <code>0x0</code> to <code>0x7fff_ffff</code> and at a mirror image location (differing only in the MSB of the address) in the range <code>0x8000_0000</code> to <code>0xffff_ffff</code>.</p></li>
</ul>
<p>In terms of bus connectivity, each shared memory peripheral must be reachable from both the MicroBlaze’s M_AXI_DC data cache interface and its M_AXI_DP data peripheral interface. A data access to an address in the cached memory range will go over the M_AXI_DC bus (if there is a cache miss), but by setting the MSB of the address to 1, the access will bypass the cache and use the M_AXI_DP bus.</p>
<p>There are two ways to achieve this additional connectivity:</p>
<ul>
<li><p><strong>Add an additional AXI slave port to each shared memory peripheral.</strong> Connect one port to the MicroBlaze’s M_AXI_DC interface (and map it to a cached address range), and connect the other port to the M_AXI_DP interface (and map it to an uncached address range that differs from the first port’s address range by just the MSB). Xilinx’s DRAM controllers typically support multiple AXI slave ports.</p></li>
<li><p><strong>Connect the M_AXI_DP bus to the M_AXI_DC bus with an AXI-to-AXI connector that also remaps addresses.</strong> VectorBlox provides an <strong>axi2axi_remap</strong> component for this purpose. (It is included in the pcores directory, and can be found in the XPS IP Catalog in the <strong>Bus &amp; Bridge</strong> category.) Connect the component’s AXI slave port to the M_AXI_DP bus, and connect its master port to the M_AXI_DC bus. Map the connector’s slave port to an address range above <code>0x8000_0000</code>, large enough to span the uncached address ranges of all shared memory peripherals. Accesses over the M_AXI_DP bus that fall within the connector’s address range are passed through to the M_AXI_DC bus, but with the MSB of the address set to 0, thus allowing uncached access to memory on the M_AXI_DC bus.</p>
<p>The advantage of this method is that it doesn’t require an additional AXI slave port to be added to existing memory peripherals.</p></li>
</ul>
<p>The figure below shows a MicroBlaze system with a two-port DRAM controller, with the first port mapped to the range <code>0x1000_0000</code> to <code>0x17ff_ffff</code> and the second port mapped to the range <code>0x9000_0000</code> to <code>0x97ff_ffff</code>.</p>
<p><img src="images/xps_mb_system_two_port_ddr.png" /> <img src="images/xps_mb_address_map_two_port_ddr.png" /></p>
<p>The figure below shows a system that uses an axi2axi_remap component to allow uncached access to the DRAM controller over the M_AXI_DP bus, in the address range <code>0x9000_0000</code> to <code>0x97ff_ffff</code>.</p>
<p><img src="images/xps_mb_system_remap.png" /> <img src="images/xps_mb_address_map_remap.png" /></p>
<h3 id="arm-cortex-a9-data-cache-bypass"><span class="header-section-number">2.4.2</span> ARM Cortex-A9 Data Cache Bypass</h3>
<p>On the ARM Cortex-A9, the translation table in the CPU's Memory Management Unit (MMU) can be used to alias the physical address range of a shared memory to two logical address ranges that differ only in address bit 31. The memory attributes of the lower address range are set to &quot;normal cacheable&quot;, whereas the attributes of the upper address range are set to &quot;strongly-ordered&quot; to make the region non-cacheable. (Setting the memory attributes of the upper range to &quot;normal non-cacheable&quot; does not seem to have the desired effect.)</p>
<p>The <em>MXP Programming Guide</em> gives an example of how to do this.</p>
<h2 id="vectorblox_mxp_instantiation"><span class="header-section-number">2.5</span> VectorBlox MXP Instantiation and Configuration</h2>
<p>The figure below shows the VectorBlox MXP core in the XPS IP Catalog.</p>
<div class="figure">
<img src="images/xps_ip_catalog.png" />
</div>
<p>To add a VectorBlox MXP instance to your system, double-click on <strong>VectorBlox MXP</strong>. XPS will open the parameter editor shown below. (<strong>Note:</strong> if you received a pre-synthesized netlist for the MXP core, you will not be able to change any of the parameters.)</p>
<div class="figure">
<img src="images/xps_core_config.png" />
</div>
<p>The parameters are described below:</p>
<dl>
<dt>Number of Vector Lanes</dt>
<dd><p>The number of 32-bit vector lanes. This must be a power of 2.</p>
</dd>
<dt>Number of Memory Lanes</dt>
<dd><p>The data bus width of the MXP DMA Engine’s AXI master interface expressed in terms of 32-bit lanes. The number of memory lanes must be a power of two and no larger than the number of vector lanes.</p>
</dd>
<dt>Maximum Burst Size in Beats</dt>
<dd><p>The maximum number of beats per burst issued by the DMA Engine’s AXI master interface. (A beat is a clock cycle in which data is transferred between a source and sink interface.)</p>
</dd>
<dt>Scratchpad Size</dt>
<dd><p>The Scratchpad RAM size in kilobytes.</p>
</dd>
<dt>Multiplier Granularity</dt>
<dd><p>Sets the minimum multiplier size. This can be used to reduce FPGA multiplier resource utilization at the cost of performance. If set to <strong>Byte</strong>, then byte, halfword, and word multipliers are instantiated and multiplication of any element size runs at full speed. If set to <strong>Halfword</strong>, only word and halfword multipliers are instantiated; byte-width multiplication will be executed with the halfword multiplier and run at half speed. If set to <strong>Word</strong>, only word multipliers are instantiated; halfword-width multiplication will run at half speed and byte-width multiplication will run at quarter speed.</p>
</dd>
<dt>Fixed-Point Multiply Format</dt>
<dd><p>These parameters affect the fixed-point multiply operation. They specify the number of least-significant bits that will be used to represent the fractional part of 32-bit, 16-bit, and 8-bit fixed-point numbers.</p>
<p>The fixed-point formats are also displayed in Q notation, where the first number specifies the number of integer bits and the second number specifies the number of fractional bits.</p>
</dd>
</dl>
<p>The core configuration dialog box also displays a couple of derived parameters:</p>
<dl>
<dt>AXI Master Data Width in Bits</dt>
<dd><p>The data bus width, in bits, of the DMA Engine’s AXI master interface. This is derived from the number of memory lanes.</p>
</dd>
<dt>Maximum Burst Size in Bytes</dt>
<dd><p>The AXI master interface’s maximum burst size in bytes, as determined by the memory bus width and the maximum number of beats per burst.</p>
</dd>
</dl>
<h2 id="vectorblox_mxp_port_connections"><span class="header-section-number">2.6</span> VectorBlox MXP Port Connections</h2>
<p>This section describes the MXP processor’s interfaces:</p>
<dl>
<dt>core_clk</dt>
<dd><p>This is the main MXP clock, as well as the AXI clock. The MXP’s AXI Master and Slave interfaces run synchronously to <strong>core_clk</strong>.</p>
</dd>
<dt>core_clk_2x</dt>
<dd><p>This clock must be double the frequency of the AXI clock <strong>core_clk</strong> and must be synchronous to <strong>core_clk</strong>. It should be generated from the same PLL that provides <strong>core_clk</strong>.</p>
</dd>
<dt>aresetn</dt>
<dd><p>This is the active low reset input. Assertion and deassertion must be synchronous to the AXI clock <strong>core_clk</strong> and <strong>core_clk_2x</strong>.</p>
</dd>
<dt>AXI4 Master</dt>
<dd><p>The <strong>M_AXI</strong> master interface is the MXP DMA Engine’s interface to external memory. The data bus width is determined by the number of memory lanes selected in the MXP Parameter Editor.</p>
</dd>
<dt>AXI4-Lite Slave</dt>
<dd><p>The <strong>S_AXI</strong> slave interface allows the MicroBlaze or ARM CPU to access the MXP’s scratchpad memory. It is typically connected to either the MicroBlaze’s M_AXI_DP bus or Zynq PS's M_AXI_GP1 port. The slave data bus is 32-bits wide.</p>
</dd>
<dt>Direct FSL Interface (MicroBlaze version only)</dt>
<dd><p>The MicroBlaze provides instructions to the MXP over a low-latency Direct FSL interface. The MXP’s FSL_SINK and FSL_SRC interfaces must be connected to the MicroBlaze’s DWFSL0 and DRFSL0 interfaces, respectively.</p>
</dd>
<dt>AXI4 Instruction Slave (ARM version only)</dt>
<dd><p>The <strong>S_AXI_INSTR</strong> slave interface is used to receive instructions from the Zynq PS. It should be connected to the Zynq PS's M_AXI_GP0 interface.</p>
</dd>
</dl>
<p>The figure below shows the XPS bus connections between MicroBlaze and MXP in a system with a two-port DDR2 DRAM controller.</p>
<div class="figure">
<img src="images/xps_mb_system_mxp.png" />
</div>
<p>The next figure shows the XPS bus connections between the Zynq Processing System and MXP in a system where the ARM Cortex-A9 and MXP share data via the the Zynq's hard DDR controller.</p>
<div class="figure">
<img src="images/xps_zedboard_arm_mxp.png" />
</div>
<p>After connecting the MXP interfaces in the <strong>Bus Interfaces</strong> tab, some ports will need to be connected in the <strong>Ports</strong> tab. To view these ports, you can use <strong>Port Filters</strong>, as shown below (check <strong>Unconnected</strong> and uncheck <strong>Connected</strong>).</p>
<div class="figure">
<img src="images/xps_mxp_unconnected_ports.png" />
</div>
<dl>
<dt>core_clk_2x</dt>
<dd><p>This must be connected to a clock that is synchronous to and twice the frequency of <strong>core_clk</strong>.</p>
</dd>
<dt>FSL_Clk (MicroBlaze version only)</dt>
<dd><p>This must be connected to the same port that provides <strong>core_clk</strong>.</p>
</dd>
</dl>
<h2 id="xps_netlist_and_bitstream_generation"><span class="header-section-number">2.7</span> XPS Netlist and Bitstream Generation</h2>
<p>Once all of the components in your system are connected correctly, you can proceed to netlist generation by selecting <strong>Hardware</strong> <span class="math"> → </span> <strong>Generate Netlist</strong>.</p>
<p>Netlist generation runs the Platgen program, which calls XST to synthesize each IP component as well as the top-level wrapper that connects all the IP components in the system.</p>
<p>Alternatively, you can directly generate the FPGA bitstream in XPS by selecting <strong>Hardware</strong> <span class="math"> → </span> <strong>Generate Bitstream</strong>. This will first generate the netlist and then run the Xilinx implementation tools (e.g. NGDBuild, MAP, PAR, TRACE, BitGen) to generate a bitstream.</p>
<h1 id="quickstart_software"><span class="header-section-number">3</span> Software</h1>
<p>This section describes how to download one of the provided pre-built FPGA bitstreams to a supported development board and how to compile and run a test program on it.</p>
<p>If you have downloaded the VectorBlox MXP preview release from github, the string <strong>TOPDIR</strong> below refers to the top-level directory from the extracted download.</p>
<p>If you have a VectorBlox MXP hardware IP release, the string <strong>TOPDIR</strong> refers to the <code>examples</code> subdirectory of the extracted release.</p>
<h2 id="software_prerequisites"><span class="header-section-number">3.1</span> Prerequisites</h2>
<p>Before you begin, make sure you have:</p>
<ul>
<li><p>Installed Xilinx ISE 14.7 or later.</p></li>
<li><p>Installed and tested the Digilent USB-JTAG drivers.</p></li>
<li><p>A supported development board/kit. See the contents of <code>TOPDIR/boards/</code></p></li>
<li><p>Connected your development board to your computer via USB cable and turned the board on.</p></li>
</ul>
<h2 id="compiling-and-running-a-test-program"><span class="header-section-number">3.2</span> Compiling and Running a Test Program</h2>
<ol style="list-style-type: decimal">
<li><p><strong>Start a Command Shell.</strong></p>
<p>In Windows, select <strong>Start Menu</strong> <span class="math"> → </span> <strong>All Programs</strong> <span class="math"> → </span> <strong>Xilinx Design Tools</strong> <span class="math"> → </span> <strong>ISE Design Suite</strong> <span class="math"> → </span> <strong>Accessories</strong> <span class="math"> → </span> <strong>ISE Design Suite 32/64 Bit Command Prompt</strong>.</p>
<p>In Linux, open a terminal and run the appropriate <code>settings{32,64}.{sh,csh}</code> script in the root of your Xilinx ISE_DS installation. (Select 32 or 64 depending on whether you want to use the 32-bit or 64-bit versions of the tools, and select sh or csh depending on whether you are using a Bourne-style shell, such as sh or bash, or a C Shell, such as csh or tcsh.) This sets up the proper environment variables for using the Xilinx development tools.</p></li>
<li><p>Navigate to one of the prebuilt VectorBlox MXP systems for your development board, located in <code>TOPDIR/boards/&lt;board_name&gt;/prebuilt_*</code>.</p>
<p>For example, for the ZedBoard, change directory to <code>TOPDIR/boards/zedboard_arm/prebuilt_zedboard_arm_v16</code> for a 16-lane MXP system.</p></li>
<li><p>Store the path to the directory in a shell variable. In Linux, assuming you are using a Bourne-style shell such as <code>sh</code> or <code>bash</code>, use</p>
<pre><code>PROJ_ROOT=`pwd`</code></pre>
<p>If using <code>csh</code> or <code>tcsh</code>, use</p>
<pre><code>set PROJ_ROOT=`pwd`</code></pre>
<p>In Windows, use</p>
<pre><code>set PROJ_ROOT=%cd%</code></pre></li>
<li><p>Navigate to a test application such as <code>vbw_vec_add_t</code>, located in <code>TOPDIR/software/bmark/vbw_vec_add_t</code>.</p></li>
<li><p><strong>Make the executable.</strong></p>
<p>To compile the program for the FPGA bitstream you previously selected, you need to pass the location of the BSP to <code>make</code>. Assuming the <code>PROJ_ROOT</code> shell variable has been set appropriately, on Linux, run</p>
<pre><code>make clean_all all PROJ_ROOT=$PROJ_ROOT</code></pre>
<p>On Windows, run</p>
<pre><code>make clean_all all PROJ_ROOT=%PROJ_ROOT%</code></pre>
<p>After a long list of messages and a few seconds, the file <strong>test.elf</strong> should have been created.</p>
<p>Note that we used the <code>clean_all</code> target first to ensure that any libraries that might have been compiled against a different BSP in the past were cleaned and re-compiled. If you know that the libraries were already compiled for the selected BSP, you can omit the <code>clean_all</code> target.</p></li>
<li><p><strong>Program the FPGA.</strong></p>
<p>We provide a make target to program the FPGA with XMD or iMPACT. In Linux, use</p>
<pre><code>make pgm PROJ_ROOT=$PROJ_ROOT</code></pre>
<p>In Windows, use</p>
<pre><code>make pgm PROJ_ROOT=%PROJ_ROOT%</code></pre></li>
</ol>
<!---
    `impact -batch etc/download.cmd`
or
    xmd:
        connect arm hw
        rst -srst
        fpga -f SDK/SDK_Export/hw/system.bit
        source SDK/SDK_Export/hw/ps7_init.tcl
        ps7_init
        ps7_post_config
        exit
-->


<ol start="8" style="list-style-type: decimal">
<li><p>Open a serial port terminal emulator to prepare to view the output from the board’s USB-UART. On Linux, you can, for example, open a new terminal and run <code>picocom -b 38400 /dev/ttyUSB0</code> for the Atlys or <code>picocom -b 115200 /dev/ttyACM0</code> for the ZedBoard. On Windows, use a program such as PuTTY to connect to the USB serial port.</p></li>
<li><p><strong>Download the executable.</strong></p>
<p>We provide a make target to download the ELF with XMD. In Linux, use</p>
<pre><code>make run PROJ_ROOT=$PROJ_ROOT</code></pre>
<p>In Windows, use</p>
<pre><code>make run PROJ_ROOT=%PROJ_ROOT%</code></pre></li>
</ol>
<!---
    `xmd -tcl xmd_mb.tcl`

         connect arm hw
         dow test.elf
         con
-->

<ol start="9" style="list-style-type: decimal">
<li><strong>View execution output.</strong> You should see output in the serial terminal emulator you opened in an earlier step. The executable may use stdin or stdout for printf, scanf, and similar functions.</li>
</ol>
<h1 id="video-demo-application"><span class="header-section-number">4</span> Video Demo Application</h1>
<p>We have written a demonstration program that runs on supported boards with video output capability. It provides a visual demonstration of the acceleration capabilities of the MXP processor by allowing the user to see the performance difference between algorithms running on the scalar host CPU alone and vectorized MXP implementations of the same algorithms.</p>
<p>On systems with video output, the algorithms demonstrated are</p>
<ul>
<li><p>A two-dimensional n-body particle repulsion simulation with 512 particles and an external force that varies according to a Lissajous pattern. Q16.16 fixed-point arithmetic is used. The MXP implementation of the algorithm uses a custom instruction pipeline that computes the sum of the forces from all other particles on a given particle. The pipeline is described in the following conference paper: A. Severance, J. Edwards, H. Omidian, G. Lemieux, &quot;Soft Vector Processors with Streaming Pipelines,&quot; to appear at <em>International Symposium on Field-Programmable Gate Arrays (FPGA)</em>, February, 2014 (<a href="http://www.ece.ubc.ca/~lemieux/publications/bytopic.html">http://www.ece.ubc.ca/~lemieux/publications/bytopic.html</a>). The MXP implementation also makes use of a custom instruction for fixed-point division, if available.</p></li>
<li><p>Mandelbrot set calculation at different zoom levels.</p></li>
<li><p>Sobel edge detection run on half of the screen after each frame of the n-body particle simulation.</p></li>
</ul>
<p>On systems that also have video input, some additional algorithms are demonstrated:</p>
<ul>
<li><p>Sobel edge detection on the video input.</p></li>
<li><p>Motion estimation (motion tracking) on the video input. Two boxes track motion in the input video using a sum-of-absolute-differences calculation. The boxes are re-centred every 400 input frames.</p></li>
<li><p>Face Detection on the video input using Haar-like features. A green box is drawn around each detected face.</p></li>
<li><p>Multi-algorithm mode with the particle simulation overlaid on top of the video input, with edge detection also running in the top left quadrant, motion estimation in the top right quadrant, and video inversion in the bottom right quadrant.</p></li>
</ul>
<h2 id="zedboard-hdmi-output-demo"><span class="header-section-number">4.1</span> ZedBoard HDMI Output Demo</h2>
<p>This ZedBoard demo displays 1920x1080p 60Hz on the HDMI port. Connect a 1080p monitor to the on-board HDMI port to see video output.</p>
<p>We have provided pre-compiled ELF files for your convenience, but you can also compile the demo yourself by following the instructions in the <a href="#compile_zedboard_hdmi_demo">section below</a>.</p>
<p>To run the demo, first open up an ISE Command Prompt, then go to the directory containing the pre-built bitstream you wish to use. e.g. for the ARM-based V16 system:</p>
<pre><code>cd boards/zedboard_hdmi_arm/prebuilt_zedboard_hdmi_arm_v16</code></pre>
<p>For the MicroBlaze-based V16 system, use</p>
<pre><code>cd boards/zedboard_hdmi_mb/prebuilt_zedboard_hdmi_mb_v16</code></pre>
<p><strong>We recommend you power-cycle the ZedBoard before loading the bitstream.</strong></p>
<p>Connect to the ZedBoard's USB-UART with a terminal emulator program to prepare to view the serial console output. Use 115200 bps, 8 bits per character, no parity.</p>
<p>Program the FPGA and download the ELF with the provided XMD Tcl script:</p>
<pre><code>xmd -tcl xmd_demo.tcl</code></pre>
<p>The DIP switches near the OLED are used to select the mode of operation.</p>
<p><strong>SW0</strong> Toggles between the Mandelbrot and Particle Repulsion algorithms.</p>
<p><strong>SW1</strong> When running Particle Repulsion, toggles Edge Detection on the left half of the screen.</p>
<p><strong>SW2</strong> Toggles between the ARM-only (or MicroBlaze-only) implementation of the algorithm (scalar mode) and the vectorized MXP implementation of the algorithm (vector mode).</p>
<h3 id="compile_zedboard_hdmi_demo"><span class="header-section-number">4.1.1</span> Recompiling the ZedBoard HDMI Output Demo</h3>
<p>From an ISE Command Prompt, go to the directory containing the pre-built bitstream you wish to use. e.g. for the ARM-based V16 system:</p>
<pre><code>cd boards/zedboard_hdmi_arm/prebuilt_zedboard_hdmi_arm_v16</code></pre>
<p>For the MicroBlaze-based V16 system, use</p>
<pre><code>cd boards/zedboard_hdmi_mb/prebuilt_zedboard_hdmi_mb_v16</code></pre>
<p>Store the path to the directory in a shell variable. In Linux use</p>
<pre><code>PROJ_ROOT=`pwd`</code></pre>
<p>in <code>sh</code> or <code>bash</code>, or</p>
<pre><code>set PROJ_ROOT=`pwd`</code></pre>
<p>in <code>csh</code> or <code>tcsh</code>.</p>
<p>In Windows, use</p>
<pre><code>set PROJ_ROOT=%cd%</code></pre>
<p>Go to the demo directory:</p>
<pre><code>cd ../../../software/demo/zedboard</code></pre>
<p>Compile the demo. In Linux, use</p>
<pre><code>make clean_all all PROJ_ROOT=$PROJ_ROOT</code></pre>
<p>In Windows, use</p>
<pre><code>make clean_all all PROJ_ROOT=%PROJ_ROOT%</code></pre>
<p>Program the FPGA. We provide a make target to do this with XMD. In Linux, use</p>
<pre><code>make pgm PROJ_ROOT=$PROJ_ROOT</code></pre>
<p>In Windows, use</p>
<pre><code>make pgm PROJ_ROOT=%PROJ_ROOT%</code></pre>
<p>Connect to the ZedBoard's USB-UART with a terminal emulator program to prepare to view the serial console output. Use 115200 bps, 8 bits per character, no parity.</p>
<p>Download the ELF to the board. Again, we provide a make target to do this with XMD. In Linux, use</p>
<pre><code>make run PROJ_ROOT=$PROJ_ROOT</code></pre>
<p>In Windows, use</p>
<pre><code>make run PROJ_ROOT=%PROJ_ROOT%</code></pre>
<h2 id="zedboard-with-fmc-imageon-hdmi-daughter-card-demo"><span class="header-section-number">4.2</span> ZedBoard with FMC-IMAGEON HDMI Daughter Card Demo</h2>
<p>The <code>zedboard_imageon</code> demo uses Avnet's FMC-IMAGEON daughter card for video input and output. A 1920x1080p 60Hz video source should be connected to the HDMI IN port, and a 1080p monitor should be connected to the HDMI OUT port.</p>
<p>We have provided pre-compiled ELF files for the demo because it uses some Avnet reference code which we do not have permission to redistribute. Please see the <a href="#compile_zedboard_imageon_demo">section below</a> if you wish to compile the demo yourself.</p>
<p>To run the demo, first open up an ISE Command Prompt, then go to the directory containing the pre-built bitstream you wish to use. e.g. for the ARM-based V16 system:</p>
<pre><code>cd boards/zedboard_imageon_arm/prebuilt_zedboard_imageon_arm_v16</code></pre>
<p>For the MicroBlaze-based V16 system, use</p>
<pre><code>cd boards/zedboard_imageon_mb/prebuilt_zedboard_imageon_mb_v16</code></pre>
<p><strong>We recommend you power-cycle the ZedBoard before loading the bitstream.</strong></p>
<p>Connect to the ZedBoard's USB-UART with a terminal emulator program to prepare to view the serial console output. Use 115200 bps, 8 bits per character, no parity.</p>
<p>Program the FPGA and download the ELF with the provided XMD Tcl script:</p>
<pre><code>xmd -tcl xmd_demo.tcl</code></pre>
<p>The DIP switches near the OLED are used to select the mode of operation.</p>
<p><strong>SW7-4</strong> should all be 0 (off).</p>
<p><strong>SW2-0</strong> are used to select from the modes below:</p>
<ul>
<li>000 - Video Pass-through</li>
<li>001 - Particle Repulsion</li>
<li>010 - Edge Detection on the input video</li>
<li>011 - Motion Estimation on the input video</li>
<li>100 - Mandelbrot</li>
<li>101 - Haar Face Detection on the input video</li>
<li>110 - Split Mode (Particle Repulsion with Edge Detection running on the right half of the screen)</li>
<li>111 - Multi Mode (Particle Repulsion overlaid on the input video with Edge Detection, Motion Estimation, Inversion running in different quadrants)</li>
</ul>
<p><strong>SW3</strong> toggles between the ARM-only (or MicroBlaze-only) implementation of the algorithm (scalar mode) and the vectorized MXP implementation of the algorithm (vector mode).</p>
<p><strong>NOTE:</strong> The pre-built bitstreams use a time-limited evaluation version of Xilinx's Chroma Resampler IP core (v_cresample) for conversion between YCbCr 4:2:2 and YCbCr 4:4:4 formats, so the video pipelines will stop working (the output will go blank) after about an hour. You will need to power cycle the board before reloading the bitstream.</p>
<h3 id="compile_zedboard_imageon_demo"><span class="header-section-number">4.2.1</span> Recompiling the ZedBoard + FMC-IMAGEON Demo</h3>
<p>We have provided pre-compiled ELFs for the demo because it uses some Avnet reference code which cannot be redistributed by others.</p>
<p>Read this section if you wish to compile the demo yourself.</p>
<p>See the file <code>00-README.txt</code> in <code>software/demo/zedboard_imageon</code> and follow the instructions for downloading the Avnet reference code that we do not have permission to redistribute. Make sure the necessary files are copied to <code>software/demo/zedboard_imageon</code>.</p>
<p>From an ISE Command Prompt, go to the directory containing the pre-built bitstream you wish to use. e.g. for the ARM-based V16 system:</p>
<pre><code>cd boards/zedboard_imageon_arm/prebuilt_zedboard_imageon_arm_v16</code></pre>
<p>For the MicroBlaze-based V16 system, use</p>
<pre><code>cd boards/zedboard_imageon_mb/prebuilt_zedboard_imageon_mb_v16</code></pre>
<p>Store the path to the directory in a shell variable. In Linux use</p>
<pre><code>PROJ_ROOT=`pwd`</code></pre>
<p>in <code>sh</code> or <code>bash</code>, or</p>
<pre><code>set PROJ_ROOT=`pwd`</code></pre>
<p>in <code>csh</code> or <code>tcsh</code>.</p>
<p>In Windows, use</p>
<pre><code>set PROJ_ROOT=%cd%</code></pre>
<p>Go to the demo directory:</p>
<pre><code>cd ../../../software/demo/zedboard_imageon</code></pre>
<p>Compile the demo. In Linux, use</p>
<pre><code>make clean_all all PROJ_ROOT=$PROJ_ROOT</code></pre>
<p>In Windows, use</p>
<pre><code>make clean_all all PROJ_ROOT=%PROJ_ROOT%</code></pre>
<p>Program the FPGA. We provide a make target to do this with XMD. In Linux, use</p>
<pre><code>make pgm PROJ_ROOT=$PROJ_ROOT</code></pre>
<p>In Windows, use</p>
<pre><code>make pgm PROJ_ROOT=%PROJ_ROOT%</code></pre>
<p>Connect to the ZedBoard's USB-UART with a terminal emulator program to prepare to view the serial console output. Use 115200 bps, 8 bits per character, no parity.</p>
<p>Download the ELF to the board. Again, we provide a make target to do this with XMD. In Linux, use</p>
<pre><code>make run PROJ_ROOT=$PROJ_ROOT</code></pre>
<p>In Windows, use</p>
<pre><code>make run PROJ_ROOT=%PROJ_ROOT%</code></pre>
<h1 id="creating_your_own_standalone_bsp"><span class="header-section-number">5</span> Creating your own Standalone BSP</h1>
<h2 id="from_the_gui"><span class="header-section-number">5.1</span> From the GUI</h2>
<ul>
<li><p>In XPS, select <strong>Project</strong> <span class="math"> → </span> <strong>Export Hardware Design to SDK…</strong>, then click <strong>Export &amp; Launch SDK</strong>. This will run Xilinx’s psf2Edward utility to generate an XML platform description file (usually in <code>SDK/SDK_Export/hw</code>), then launch the SDK.</p></li>
<li><p>In the Xilinx SDK, select the <strong>Xilinx Tools</strong> menu, then <strong>Repositories</strong>.</p></li>
<li><p>The <strong>Preferences</strong> dialog box will open, with the <strong>Repositories</strong> page already selected.</p>
<p>If you copied the VectorBlox MXP <code>drivers</code> and <code>sw_services</code> directories to the Xilinx EDK installation directory as described in the installation section, you should see the directory corresponding to <code>$(XILINX_EDK)/sw/VectorBlox</code> under <strong>SDK Installation Repositories</strong>.</p>
<p>If you did not do this, you must now add the location of these directories (i.e. their common parent directory) to the software repository list. Click <strong>New…</strong> next to either <strong>Local Repositories</strong> or <strong>Global Repositories</strong>, and add the repository location. Click <strong>OK</strong> to close the Preferences dialog box.</p></li>
<li><p>From the <strong>File</strong> menu, select <strong>New</strong> <span class="math"> → </span> <strong>Board Support Package</strong>.</p></li>
<li><p>Give your BSP a project name, and under <strong>Board Support Package OS</strong>, select <strong>standalone</strong>. Click <strong>Finish</strong>.</p></li>
<li><p>In the <strong>Board Support Package Settings</strong> dialog box, click on <strong>Overview</strong> in the left panel, and look at the <strong>Supported Libraries</strong> section. You should see an entry for <strong>vbxware</strong>, the VBXWare Library, as in the figure below.</p>
<div class="figure">
<img src="images/xsdk_bsp_libraries.png" />
</div>
<p>If you do not see the VBXWare library listed, the likely reason is that the VectorBlox <strong>sw_services</strong> directory is not in the SDK repository search path.</p>
<p>You can check the box next to <strong>vbxware</strong> if you wish to include the VBXWare library in your BSP. However, <strong>do not</strong> check this box if you wish to compile and run the VectorBlox-supplied test programs because the Makefiles for these programs compile the VBXWare library separately from the BSP.</p></li>
<li><p>In the same dialog box, click on <strong>drivers</strong> in the left panel. Check that the vectorblox_mxp driver is assigned to the the vectorblox_mxp component. See below.</p>
<div class="figure">
<img src="images/xsdk_driver_assignment.png" />
</div>
<p>If the vectorblox_mxp driver is not available as an option, the likely reason is that the VectorBlox <strong>drivers</strong> directory is not in the SDK repository search path.</p></li>
<li><p>Click <strong>OK</strong> to close the BSP Settings dialog box and compile the standalone BSP library <code>libxil.a</code>.</p></li>
</ul>
<h2 id="from_the_command_line"><span class="header-section-number">5.2</span> From the Command-line</h2>
<p>This section describes how to generate a standalone BSP from the command-line.</p>
<ul>
<li><p>Change directory to your XPS project directory.</p></li>
<li><p>Generate the XML hardware description with</p>
<pre><code>make -f system.make exporttosdk</code></pre></li>
<li><p>Run Xilinx’s appguru utility to create an MSS file from the XML file and the repository search path:</p>
<pre><code>appguru -hw SDK/SDK_Export/hw/system.xml \\
  -pe microblaze_0 -lp . -app empty_application -od bsp</code></pre>
<p>This command creates the files for the XSDK &quot;Empty Application&quot; template in the output directory <code>bsp</code>. It uses the XML hardware specification in <code>$SDK/SDK_Export/hw/system.xml</code> and targets the MicroBlaze processor instance <code>microblaze_0</code>. The <code>-lp .</code> option adds the current directory to the software repository search path.</p>
<p><strong>Note:</strong> If targeting the ARM Cortex-A9 CPU in a Zynq FPGA, use <code>ps7_cortexa9_0</code> as the processor instance instead of <code>microblaze_0</code>.</p></li>
<li><p>The generated MSS file in <code>bsp/system.mss</code> should contain an entry assigning the vectorblox_mxp driver to the vectorblox_mxp hardware instance, e.g.</p>
<pre><code>BEGIN DRIVER
 PARAMETER DRIVER_NAME = vectorblox_mxp
 PARAMETER DRIVER_VER = 1.00.a
 PARAMETER HW_INSTANCE = vectorblox_mxp_0
END</code></pre></li>
<li><p>If you want to include the VBXWare library in the BSP, you must manually add the following lines to <code>bsp/system.mss</code>.</p>
<pre><code>BEGIN LIBRARY
 PARAMETER LIBRARY_NAME = vbxware
 PARAMETER LIBRARY_VER = 1.00.a
END</code></pre>
<p>However, <strong>do not</strong> add these lines if you wish to compile and run the VectorBlox-supplied test programs because the Makefiles for these programs compile the VBXWare library separately from the BSP.</p></li>
<li><p>Extract the CPU-specific compilation flags from the generated Makefile:</p>
<pre><code>grep ^CC_FLAGS bsp/Makefile &gt; bsp/bsp_vars.mk
sed -i &#39;s/^CC_FLAGS/CPU_FLAGS/&#39; bsp/bsp_vars.mk</code></pre>
<p>The <code>CPU_FLAGS</code> variable is used by the Makefiles for the VectorBlox-supplied programs in <code>TOPDIR/software/bmark</code>.</p></li>
<li><p>Define the <code>PROCESSOR_TYPE</code> and <code>PROCESSOR_INSTANCE</code> variables in <code>bsp_vars.mk</code>. E.g.</p>
<pre><code>echo &quot;PROCESSOR_TYPE := microblaze&quot; &gt;&gt; bsp/bsp_vars.mk
echo &quot;PROCESSOR_INSTANCE := microblaze_0&quot; &gt;&gt; bsp/bsp_vars.mk</code></pre>
<p><strong>Note:</strong> If targeting the ARM Cortex-A9 CPU in a Zynq FPGA, use <code>cortexa9</code> as the processor type and e.g. <code>ps7_cortexa9_0</code> as the processor instance.</p></li>
<li><p>Remove unneeded files:</p>
<pre><code>rm -f bsp/README.txt bsp/Makefile</code></pre></li>
<li><p>Generate the BSP from the MSS file:</p>
<pre><code>libgen -hw SDK/SDK_Export/hw/system.xml -pe microblaze_0 \\
       -lp . -od bsp   bsp/system.mss</code></pre>
<p><strong>Note:</strong> If targeting the ARM Cortex-A9 CPU in a Zynq FPGA, use <code>ps7_cortexa9_0</code> as the processor instance instead of <code>microblaze_0</code>.</p></li>
</ul>
<h1 id="compiling_with_a_different_bsp"><span class="header-section-number">6</span> Compiling the Test Programs with a different Standalone BSP</h1>
<p>To compile the programs in <code>TOPDIR/software/bmark</code> with a different standalone BSP, there are some additional steps you must take:</p>
<ul>
<li><p>Open the file <code>TOPDIR/software/common/xil_vars.mk</code> for editing.</p>
<ul>
<li><p>Change the <code>PROJ_ROOT</code> variable to point to the root of your XPS project directory.</p></li>
<li><p>Change the <code>HW_PLATFORM_XML</code> variable to point to the XML file generated by the psf2Edward program during the &quot;Export to SDK&quot; procedure. Normally the file can be found in the directory <code>$(PROJ_ROOT)/SDK/SDK_Export/hw</code>.</p></li>
<li><p>Change the <code>BSP_ROOT_DIR</code> variable to point to the root of BSP directory. Ensure that <code>BSP_INC_DIR</code> and <code>BSP_LIB_DIR</code> point to the correct <code>include</code> and <code>lib</code> subdirectories.</p></li>
<li><p>Change the <code>LD_SCRIPT</code> variable to point to the linker script you wish to use. In your linker script, use a stack size of 8 MB and a heap size of 64 MB if you want to be able to run all of the test programs.</p></li>
</ul></li>
<li><p>Create a file called <strong>bsp_vars.mk</strong> in <code>$(BSP_ROOT_DIR)</code> that defines the variables <code>CPU_FLAGS</code>, <code>PROCESSOR_TYPE</code>, and <code>PROCESSOR_INSTANCE</code>. <code>CPU_FLAGS</code> contains the compiler flags specific to the CPU configuration for your system. For example, on a MicroBlaze-based system, this might look like:</p>
<pre><code>CPU_FLAGS := -mlittle-endian -mxl-barrel-shift \\
  -mxl-pattern-compare -mcpu=v8.40.b -mno-xl-soft-mul</code></pre>
<p>On an ARM-based system this would typically be empty, i.e.</p>
<pre><code>CPU_FLAGS :=</code></pre>
<p><code>PROCESSOR_TYPE</code> should be set to either <code>microblaze</code> or <code>cortexa9</code>; it determines which compiler and linker to use. <code>PROCESSOR_INSTANCE</code> should be the name of the CPU instance, usually <code>microblaze_0</code> or <code>ps7_cortexa9_0</code>. It is used to construct the <code>BSP_INC_DIR</code> and <code>BSP_LIB_DIR</code> variables (the paths to the BSP <code>include</code> and <code>lib</code> subdirectories).</p></li>
</ul>
</div>
</div>
</div>
<script src="js/jquery-1.8.3.min.js"></script>
<script src="js/jquery-ui-1.9.1.custom.min.js"></script>
<script src="js/bootstrap.js"></script>
<script src="js/jquery.tocify.min.js"></script>
<script>
$(function() {
    var toc = $("#toc").tocify({
        selectors: "h1, h2",
        history: false,
        smoothScrollSpeed: "fast",
        }).data("toc-tocify");
      $(".optionName").popover({ trigger: "hover" });
});
</script>
</body>
</html>
